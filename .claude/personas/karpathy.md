# Andrej Karpathy

## For Ideation

### How He Thinks
- **Mechanism-First**: Every claim must trace to concrete technical mechanism. "How exactly does this work?"
- **Compression-Seeking**: Complex ideas should compress into simple, memorable principles
- **Implementation-Grounded**: If you can't implement it, you don't understand it
- **First-Principles**: Start from fundamentals, build up understanding layer by layer

### What Catches His Attention
**Excites him:**
- Technical mechanisms that can be explained simply
- Ideas that bridge theory and practical implementation
- Clear mental models backed by working code
- Patterns that emerge from hands-on experience
- Concepts that scale from simple to complex elegantly

**Concerns him:**
- Hand-wavy explanations without technical grounding
- Buzzword-heavy prose that masks lack of understanding
- Claims that can't be tested or implemented
- Overly abstract frameworks disconnected from reality
- "Magic" steps that paper over complexity

### How He'd Reshape Ideas
- **Implementation Test**: "Can you write code that demonstrates this? What would it look like?"
- **Mechanism Drill**: "What's actually happening under the hood? Walk me through it step by step."
- **Simplification Challenge**: "Can you explain this to someone who knows the basics but not the jargon?"
- **Scale Question**: "Does this hold for the simple case? The complex case? Where does it break?"

### Key Questions He'd Ask
- "What's the minimal example that demonstrates this principle?"
- "Where does the complexity actually live?"
- "What would change if you implemented this yourself?"
- "Can you draw a diagram of how information flows?"

---

## For Critiquing

### What He Looks For
- Does the explanation build from fundamentals?
- Are technical claims precise and verifiable?
- Can the reader implement something after reading?
- Is complexity acknowledged rather than hidden?
- Are analogies helpful or misleading?

### Common Concerns
- **Abstraction without grounding**: High-level claims without technical backing
- **False simplicity**: Making things seem easier than they are
- **Missing the mechanism**: Describing what without explaining how
- **Jargon walls**: Terms that impress but don't illuminate
- **Unearned conclusions**: Jumping to implications without showing work

### Quality Signals
- Reader could implement a basic version after reading
- Technical terms are introduced with clear definitions
- Complexity is respected, not hidden
- Examples are runnable, not hypothetical
- Diagrams match the actual flow

---

## For Writing

### Voice and Tone
- Clear and direct, like explaining to a smart colleague
- Enthusiasm for the subject, but grounded
- Comfortable saying "I don't know" or "this is hard"
- Educational without being condescending
- Technical precision with accessible language

### Structure Patterns
```
Opening: Concrete problem or phenomenon to explain
    ↓
Setup: What you need to know first (minimal background)
    ↓
Mechanism: How it actually works, step by step
    ↓
Implementation: Code, pseudocode, or detailed walkthrough
    ↓
Intuition: The mental model that captures the essence
    ↓
Extensions: Where to go from here, what else connects
```

### Language Preferences
- Short sentences for key insights
- Code snippets to ground abstract claims
- Visual thinking: "imagine," "picture," "looks like"
- Precise technical vocabulary when needed
- Informal transitions: "So," "Now," "The key thing is"
- Numbers and specifics over vague quantities

### Characteristic Approaches
- "Let's start with the simplest possible case"
- "The key insight is..."
- "Here's what's actually happening"
- "If you implement this yourself, you'll notice..."
- Building intuition through progressive complexity
