---
layout: post
title: Heroku Dyno-wha??
date: '2013-04-09T09:55:00.003-07:00'
author: Julie Yaunches
tags: 
modified_time: '2013-04-09T10:09:48.201-07:00'
thumbnail: http://1.bp.blogspot.com/-kmlqaxq3pBM/UWRJJPLEvDI/AAAAAAAAAdU/rViMW7HH-mQ/s72-c/dinosaurs.jpg
blogger_id: tag:blogger.com,1999:blog-1290902463505407248.post-690117368561968002
blogger_orig_url: http://codingformangos.blogspot.com/2013/04/heroku-dynos-explained.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-kmlqaxq3pBM/UWRJJPLEvDI/AAAAAAAAAdU/rViMW7HH-mQ/s1600/dinosaurs.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="267" src="http://1.bp.blogspot.com/-kmlqaxq3pBM/UWRJJPLEvDI/AAAAAAAAAdU/rViMW7HH-mQ/s400/dinosaurs.jpg" width="400" /></a></div><br /><br />I've been using Heroku for a few months to host rails app that serves as the backend to a iOS app I've been working on. Heroku has been awesome because it's incredible easy to deploy your web app to a production environment seamlessly.<br /><br />How does all of this work behind the scenes, however? Let's start with what Heroku calls the 'basic unit of composition'.<br /><h3 style="text-align: center;">Dynos</h3><div><br /></div><div>These are essentially each a virtualized Unix container. You execute commands against them. They start out with a default environment (Heroku's <a href="https://devcenter.heroku.com/articles/cedar">Cedar stack</a>). When your app gets installed onto one of these (as a slug.. more on this later!) commands are executed against it based on your app and it's dependencies.</div><div><br /></div><div><u>Web vs. Worker dynos</u></div><div><br /></div><div>Web dynos serve web requests. If your web requests trigger things like fetching data from remote APIs or uploading data to S3, these can potentially tie up your web dyno. Worker dynos come in here. You can use a strategy that delegates these processes to a job queue and worker dynos will pick things up from this queue.&nbsp;</div><div><br /></div><div>So, how do you scale these two types of dynos?</div><div><ul style="text-align: left;"><li>Use more web dynos to support more concurrent users</li><li>Use more worker dynos when your job queue starts getting backed up.</li></ul><div><br /></div></div><div>All manual activity like console sessions, or rake tasks trigger a 'one-off' dyno where they run in isolation. This includes all of your 'heroku run' this or that commands?&nbsp;</div><div><br /></div><div><u>The Job Queue</u></div><div><br /></div><div>This image is a good&nbsp;visualization&nbsp;for how it works.</div><div><br /><div class="separator" style="clear: both; text-align: center;"><img border="0" height="224" src="http://3.bp.blogspot.com/-37ARzci8rEw/UWQxu3VNsaI/AAAAAAAAAdE/yJkRtZUxjqI/s320/background+jobs+heroku.png" width="320" /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Backgrounding tasks or processes is a concept. Heroku doesn't define how to implement this. With RoR, I've used Resque successfully.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"></div><div>If the user request that triggers the job needs to await the response, you do need to come up with a strategy for getting it to them when the process finishes. Polling to see when their job has finished is generally acceptable.</div><div><br /></div></div><div style="text-align: left;"><u>Dyno Management</u></div><div><br /></div><div>What manages these different dynos and makes sure they're in sync? Heroku uses it's dyno manifold to do this. When you deploy new code, all of your app's dynos are restarted. The dyno manifold also monitors your dynos for errors or issues and restarts or moves them accordingly. I think the way the dyno manifold is implemented is one of Heroku's secrets as I haven't been able to find documentation anywhere. They do say that it coordinates your dynos, manages the programs that operate your app and generally allows you to remain hands-off in how it works. <br /><br /><u>Slug Compilation</u><br /><br />When you git push to Heroku, the code is received by the <a href="https://devcenter.heroku.com/articles/slug-compiler">slug compiler</a>. This transforms your repository into a 'slug'. These are precompressed and pre-packaged copies of your application optimized for distribution by the dyno manifold. When you scale your application by increasing web or worker dynos, these slugs are distributed and expanded on each new dyno as well.</div><div><br /></div><div><u>Dyno Idling</u></div><div><u><br /></u></div><div>One thing you'll care about immediately after beginning to use Heroku will be the dyno idling policy. If your app has only a single web dyno running (this is the default and free option), it will idle out - irrespective of the number of worker dynos. This means that if you have no web requests for 1 hour, your app is effectively put to 'sleep' (idled).&nbsp;</div><div><br /></div><div>Subsequent requests to an idled app will result in the dyno manifold for the app being signaled to unidle or 'wake up' your dyno. This can result in a delay of up to 15 seconds... sometimes longer. Pretty annoying and incentive to increase your number of web dynos to ensure one is always there to receive a request.</div><div><br /></div><div>Check out the Heroku <a href="https://devcenter.heroku.com/articles/dynos">documentation</a> for dynos as well. This is where I got most of my information!</div><div><br /></div></div>