---
layout: post
title: iOS memory management with ARC
date: '2013-03-12T10:10:00.000-07:00'
author: Julie Yaunches
tags: 
modified_time: '2013-03-12T10:10:13.125-07:00'
blogger_id: tag:blogger.com,1999:blog-1290902463505407248.post-5747702236209020166
blogger_orig_url: http://codingformangos.blogspot.com/2013/03/ios-memory-management-with-arc.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">I've been learning iOS development over the last few months. I've been lucky enough to be working with iOS's ARC or <i>automatic reference counting</i>. This is what was introduced in iOS 5 and makes life a lot easier for iOS developers.<br /><br />To understand how ARC works, a few concepts involving application memory need to be considered.<br /><br /><b>The Heap</b><br /><br />This is the part of memory where all Objective-C objects are stored. When you send the&nbsp;<b><i>alloc</i></b> as a message to a given class, a chunk of memory is allocated from the heap for this new instance. This chunk includes space for the object's instance variables. However, if these instance variables are references to other objects, those objects are stored in their own heap allocation.<br /><br />Pointers are used to remember where objects are stored in the heap.<br /><br /><b>The Stack</b><br /><br />If the heap can be visualized as a heap of objects we reference via pointers, the stack can be visualized as a stack of frames (or chunks of memory). Frames from the stack are allocated as methods are executed and they store variables declared inside the method (i.e. local variables).<br /><br />If you think about it. Most programs start by running some sort of main function. This would be the first frame on the stack. If it calls another method which then calls another method... each of these would get new frames allocated from the stack. As each method finishes, it's frame is popped off the stack and destroyed.<br /><br /><b>Pointers</b><br /><b><br /></b>These point to objects stored in the heap.<br /><b><br /></b>These can exist in 2 forms:<br /><br /><ol style="text-align: left;"><li>As references from the local variables defined by methods using frames on the stack.</li><li>As references from instance variables on another object stored within the heap</li></ol><div><b>Memory Management</b></div><div><b><br /></b></div><div>Heap memory is obviously not endless. It is important to destroy objects that are no longer needed to make room for new objects. It is also very important to not destroy objects that are STILL needed.</div><div><br /></div><div>Object ownership is what helps in determining whether an object should be destroyed or not.</div><div><ul style="text-align: left;"><li>An object with no owners can be destroyed</li><li>An object with one or more owners can not be destroyed</li></ul><div><b>iOS's ARC</b></div></div><div><b><br /></b></div><div>Automatic reference counting was introduced in iOS 5 and takes care of deciding which objects have owners and which don't. And destroys those that don't! Before this, you would have to manage memory yourself using <i><b>retain</b></i> and <i><b>release</b></i> messages.</div><div><br /></div><div>ARC now takes care of most of this for you, but it's still important to know what's going on behind the scenes in case you need to step in at some point.</div><div><br /></div><div>How does ARC know an object doesn't have any more owners? It keeps track of all pointers to that object as they are created. Later, a number of things can happen to these pointers which mean they don't 'own' the object at the other end of the pointer.</div><div><ol style="text-align: left;"><li>The pointer is changed to point to another object</li><li>The pointer is set to nil</li><li>The variable holding the pointer is destroyed</li></ol><div>The last one is interesting because, as objects own other objects, which can own other objects.. the destruction of a single object can set off a chain reaction of loss of ownership and subsequent object destruction.</div></div><div><br /></div><div><b>Your Hook in ARC</b></div><div><b><br /></b></div><div>In Objective-C you're able to define variables as having strong or weak references. This ties directly into how ARC will manage the objects pointed to by these variables.</div><div><br /></div><div><u>Strong Reference</u> - This encompasses the discussion so far. If a variable is defined as pointing to an object, that object will never be destroyed.</div><div><br /></div><div><u>Weak Reference</u> - A variable that does not take ownership of the object it points to. If an object only has pointers from weak references pointing to it, it will be destroyed</div><div><br /></div><div>Why have weak references? They're mostly used for retain cycles. This is when two or more objects have strong references to each other. This is bad because neither of these (or any objects they own) will ever be destroyed, even if all other pointers to both have been removed.</div><div><br /></div><div>An interesting thing about weak references is that they know when the object they point to is destroyed. They are set to nil in this case. This will prevent any exceptions from occurring if the object containing that weak reference ever tries to use it.</div><div><br /></div><div><b>Conclusion</b></div><div><b><br /></b></div><div>So, if all those strong vs. weak variable definitions were confusing you (as they did me at first) there you go. It's the framework for memory management in Objective-C.</div></div>